# -*- coding: utf-8 -*-
"""Untitled42.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fIOF1rRtKY9bx7v83Oqzl69jOsEkydnf
"""

import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
import numpy as np
import pandas as pd
import random
from torch_geometric.data import Data
from torch_geometric.nn import GCNConv
from sklearn.preprocessing import StandardScaler
from sklearn.utils.class_weight import compute_class_weight
import joblib

# Set random seed for reproducibility
def set_seed(seed=42):
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False

set_seed(42)

# ✅ Sample Data
data = {
    "transaction_id": ["txn_100001", "txn_100002", "txn_100003", "txn_100004"],
    "transaction_amount": [500, 7000, 1200, None],  # Missing value
    "account_balance": [10000, 1500, 2000, 500],
    "transaction_payment_mode_anonymous": [3, 10, 7, 5],
    "payment_gateway_bank_anonymous": [20, 35, 15, 40],
    "payer_browser_anonymous": [1200, 1500, 1100, 1400],
    "is_fraud": [0, 1, 0, 1]  # Fraud Labels
}
df = pd.DataFrame(data)

# ✅ Data Preprocessing
df["transaction_amount"].fillna(df["transaction_amount"].median(), inplace=True)

# Ensure Consistent Features
feature_columns = ["transaction_amount", "account_balance", "transaction_payment_mode_anonymous",
                   "payment_gateway_bank_anonymous", "payer_browser_anonymous"]
features = df[feature_columns]

# Standardize features
scaler = StandardScaler()
scaled_features = scaler.fit_transform(features)
joblib.dump(scaler, "scaler.pkl")  # Save scaler

# Convert to tensors
X = torch.tensor(scaled_features, dtype=torch.float)
y = torch.tensor(df["is_fraud"].values, dtype=torch.float).unsqueeze(1)  # Fix shape mismatch

# Compute Class Weights
class_weights = compute_class_weight(class_weight="balanced", classes=np.array([0, 1]), y=df["is_fraud"].values)
class_weights = torch.tensor(class_weights, dtype=torch.float)

# ✅ Graph Construction
edge_index = torch.tensor([[0, 1, 2, 3], [1, 2, 3, 0]], dtype=torch.long)  # Example edges
graph_data = Data(x=X, edge_index=edge_index)

# ✅ Define Optimized GNN Model
class GNNFraudModel(nn.Module):
    def __init__(self, input_dim, hidden_dim, output_dim):
        super(GNNFraudModel, self).__init__()
        self.conv1 = GCNConv(input_dim, hidden_dim)
        self.conv2 = GCNConv(hidden_dim, hidden_dim)
        self.batch_norm = nn.BatchNorm1d(hidden_dim)  # Improves stability
        self.dropout = nn.Dropout(0.5)  # Regularization
        self.fc = nn.Linear(hidden_dim, output_dim)

    def forward(self, data):
        x, edge_index = data.x, data.edge_index
        x = F.relu(self.conv1(x, edge_index))
        x = self.batch_norm(x) if x.shape[0] > 1 else x  # ✅ Avoid BatchNorm error for single inputs
        x = F.relu(self.conv2(x, edge_index))
        x = self.dropout(x)
        x = self.fc(x)
        return torch.sigmoid(x)  # Binary classification

# ✅ Initialize Model
model = GNNFraudModel(input_dim=5, hidden_dim=8, output_dim=1)
optimizer = optim.Adam(model.parameters(), lr=0.01, weight_decay=1e-4)  # L2 Regularization
criterion = nn.BCELoss(weight=class_weights[1])

# ✅ Training Function with Early Stopping
def train_model(model, data, epochs=100, patience=10):
    model.train()
    best_loss = float("inf")
    patience_counter = 0

    for epoch in range(epochs):
        optimizer.zero_grad()
        output = model(data)
        loss = criterion(output, y)  # Fix shape mismatch
        loss.backward()
        optimizer.step()

        if epoch % 10 == 0:
            print(f"Epoch {epoch}: Loss = {loss.item():.4f}")

        # Early stopping
        if loss.item() < best_loss:
            best_loss = loss.item()
            patience_counter = 0
            torch.save(model.state_dict(), "best_model.pth")  # Save best model
        else:
            patience_counter += 1
            if patience_counter >= patience:
                print("Early stopping triggered")
                break

    print("Training Complete.")

# ✅ Train Model
train_model(model, graph_data)

# ✅ Load Best Model
model.load_state_dict(torch.load("best_model.pth"))
model.eval()

# ✅ Fraud Prediction Function
def predict_fraud(model, sample_transaction, transaction_id):
    """
    Corrected fraud prediction function that ensures input passes through the GNN layers.
    """
    with torch.no_grad():
        # Convert sample to tensor
        transaction_features = torch.tensor(sample_transaction, dtype=torch.float).unsqueeze(0)  # ✅ Ensure batch size ≥ 1

        # Dummy self-loop edge index for single transaction
        edge_index = torch.tensor([[0], [0]], dtype=torch.long)

        # Create PyG Data object
        transaction_graph = Data(x=transaction_features, edge_index=edge_index)

        # Pass through the full model forward pass
        prediction = model(transaction_graph)

        # Extract fraud probability
        fraud_score = prediction.squeeze().detach().cpu().numpy()
        is_fraud = fraud_score > 0.5

    return {
        "transaction_id": transaction_id,
        "is_fraud": bool(is_fraud),
        "fraud_source": "model",
        "fraud_reason": "Suspicious transaction pattern detected" if is_fraud else "No suspicious activity detected",
        "fraud_score": round(float(fraud_score), 4)
    }

# ✅ Example Prediction
sample_transaction = {
    "transaction_id": "txn_300003",
    "transaction_amount": 600.00,
    "account_balance": 8500,
    "transaction_payment_mode_anonymous": 3,
    "payment_gateway_bank_anonymous": 6,
    "payer_browser_anonymous": 1400
}

# Standardize new transaction
scaler = joblib.load("scaler.pkl")
sample_transaction_features = scaler.transform([[sample_transaction["transaction_amount"],
                                                 sample_transaction["account_balance"],
                                                 sample_transaction["transaction_payment_mode_anonymous"],
                                                 sample_transaction["payment_gateway_bank_anonymous"],
                                                 sample_transaction["payer_browser_anonymous"]]])

# Predict fraud status
output_json = predict_fraud(model, sample_transaction_features, sample_transaction["transaction_id"])
print(output_json)
torch.save(model.state_dict(), "gnn_fraud_model.pt")
print("✅ Model saved successfully as gnn_fraud_model.pt")
